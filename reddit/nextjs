
```
https://developers.caffeina.com/how-to-get-a-100-lighthouse-score-with-nextjs-c2fa4d35a90b

How to get a 100% Lighthouse score with NextJS
Today we will talk about how to get 100% on all four categories of Lightouse:

Progressive Web Apps
Performance
Accessibility
Best Practices
What is Lighthouse ?
Lighthouse is a tool introduced by Google IO in 2017. Lighthouse runs a barrage of tests against the page, and then generates a report on how well the page did. From here you can use the failing tests as indicators on what you can do to improve your app. The tool is very simple to use, we just need to open the developer console of Chrome, click on the Audit tab and start a new Audit. The result well be like this:


Let¡¯s start to code
For this test we will use the npm create-next-app package which gives us a good starting structure

npm install -g create-next-app

create-next-app test-next-lighthouse
cd test-next-lighthouse/
yarn dev
And tad¨¤:


Now let¡¯s start with the first, and more difficult, step.

Progressive Web Apps
Progressive Web Apps, also known as Installable Web Apps or Hybrid Web Apps, are regular web pages or websites, but can appear to the user like traditional applications or native mobile applications. The application type attempts to combine features offered by most modern browsers with the benefits of mobile experience.

The foundamental points to resolve to get an high score are:

Redirect http traffic to https
Does not register a Service Worker
Does not respond with a 200 when offline
User will not be prompted to Install the Web App
Is not configured for a custom splash screen
Address bar does not match brand colors
Redirect http traffic to https
This is not a change to the NextJS code, we could also do it via NodeJS but I do not recommend it, it¡¯s just a small change to our nginx virtualhost configuration

server {
        listen 80;
        server_name YOURSERVERNAME;
        location / {
                proxy_pass http://127.0.0.1:3000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host $host;
                proxy_cache_bypass $http_upgrade;
        }
        listen 443 ssl;
        ssl_certificate YOURCERTIFICATE/PATH
        ssl_certificate_key YOURCERTIFICATE/PATH
        ssl_dhparam YOURCERTIFICATE/PATH
        if ($scheme != "https") {
          return 301 https://$host$request_uri;
        }
}
Does not register a Service Worker / Does not respond with a 200 when offline
To resolve this two points we will create a simple Service worker that caches the generated static files (js, css and images) to make our site available even a user return without an internet connection. To helps us we will use webpack and the sw-precache-webpack-plugin.

Let¡¯s start to create the service worker

Under the folder utils we will create the offline.js , this file will be included into our main.js from webpack. The script is very simple:

if (
  typeof window !== ¡®undefined¡¯ &&
  ¡®serviceWorker¡¯ in navigator
) {
     navigator.serviceWorker
     .register(¡®/sw.js¡¯)
     .then(function(reg) {
       console.log(¡®Service worker registered¡®);
     })
     .catch(function(e) {
       console.error(¡®Error during worker registration:¡¯, e);
     });
   }
Now we can install the sw-precache-webpack-plugin with yarn add sw-precache-webpack-plugin --devand edit our next.config.js to use this plugin in production:

const path = require(¡®path¡¯)
const SWPrecacheWebpackPlugin = require(¡®sw-precache-webpack-plugin¡¯)
module.exports = {
  webpack: (config, {dev}) => {
    const oldEntry = config.entry
    config.entry = () => oldEntry().then(entry => {
      entry[¡®main.js¡¯].push(path.resolve(¡®./utils/offline¡¯))
      return entry
    })
    if(!dev){
      config.plugins.push(new SWPrecacheWebpackPlugin({
        cacheId: ¡®test-lighthouse¡¯,
        filepath: path.resolve(¡®./static/sw.js¡¯),
        staticFileGlobs: [
          ¡®static/**/*¡¯
        ],
        minify: true,
        staticFileGlobsIgnorePatterns: [/\.next\//],
        runtimeCaching: [{
          handler: ¡®fastest¡¯,
          urlPattern: /[.](png|jpg|css)/
        },{
          handler: ¡®networkFirst¡¯,
          urlPattern: /^http.*/
        }]
      }))
    }
    return config
  }
}
Inside the SWPrecacheWebpackPlugin we will define the:

Cache ID: used to save our cache into the cache storage
Filepath: used to save the effective sw file
staticFileGlob: The path of the static contents that we need to cache
staticFileGlobsIgnorePatterns: The paths of the files that we need to ignore from the cache
runtimeCaching: Define the type of the cache for all the file types
Now we need to edit the server.js file to serve our genereted sw.js in /sw.js

const { createServer } = require(¡®http¡¯)
const path = require(¡®path¡¯)
const next = require(¡®next¡¯)
const dev = process.env.NODE_ENV !== ¡®production¡¯
const app = next({ dir: ¡®.¡¯, dev })
const handle = app.getRequestHandler()
const PORT = process.env.PORT || 3000
app.prepare().then(_ => {
  const server = createServer((req, res) => {
    if (req.url === ¡®/sw.js¡¯) {
      app.serveStatic(req, res, path.resolve(¡®./static/sw.js¡¯))
    } else {
      handle(req, res)
    }
  })
  server.listen(PORT, err => {
    if (err) throw err
    console.log(`> App running on port ${PORT}`)
  })
})
Almost done, now we modify the scripts inside the package.json to use the server.js and start (yarn start) the application

...
¡°scripts¡±: {
   ¡°dev¡±: ¡°node server¡±,
   ¡°prestart¡±: ¡°next build¡±,
   ¡°start¡±: ¡°NODE_ENV=production node server¡±
},
Open the developer console of Chrome on the Application tab and the service worker is magically registered


We can play with the offline options but all works great :)

User will not be prompted to Install the Web App / Is not configured for a custom splash screen / Address bar does not match brand colors
Solving these issues is very simple: all progressive web apps need a manifest where to define behaviors or variables like the name, the same as you¡¯d do for a mobile application.

Inside the static folder just create the manifest.json file

{
  ¡°name¡±: ¡°Next lighthouse¡±,
  ¡°short_name¡±: ¡°Next LH¡±,
  ¡°icons¡±: [{
    ¡°src¡±: ¡°img/apple-touch-icon-120x120.png¡±,
    ¡°sizes¡±: ¡°120x120¡±,
    ¡°type¡±: ¡°image/png¡±
  },{
    ¡°src¡±: ¡°img/apple-touch-icon-152x152.png¡±,
    ¡°sizes¡±: ¡°152x152¡±,
    ¡°type¡±: ¡°image/png¡±
  },{
    ¡°src¡±: ¡°img/android-chrome-144x144.png¡±,
    ¡°sizes¡±: ¡°144x144¡±,
    ¡°type¡±: ¡°image/png¡±
  },{
    ¡°src¡±: ¡°img/android-chrome-192x192.png¡±,
    ¡°sizes¡±: ¡°192x192¡±,
    ¡°type¡±: ¡°image/png¡±
  },{
    ¡°src¡±: ¡°img/splashscreen-icon-384x384.png¡±,
    ¡°sizes¡±: ¡°384x384¡±,
    ¡°type¡±: ¡°image/png¡±
  }],
  ¡°start_url¡±: ¡°/¡±,
  ¡°display¡±: ¡°fullscreen¡±,
  ¡°theme_color¡±: ¡°#673ab7¡±,
  ¡°background_color¡±: ¡°#EEE¡±
}
Inside the manifest.json we will define the:

Name: Just the name of our app
Short_name: A short version of the name of the app
Icons: Used when our app will be added on the locscreen and in the splash screen
Start_url: the base url (in this case / but can be any path)
Display: the way our app will be open
Theme_color: our primary color, this will be used in the address bar (and navbar)
Background_color: our background color
Almost done, now we just need to add the manifest declaration inside the NextHead tag and it¡¯s done

import NextHead from 'next/head'
const Head = (props) => (
  <NextHead>
    <link rel="manifest" href="/static/manifest.json" />
    ...
  </NextHead>
)
Performance
This is the most critical point of the four. This is actually measured in how much time the page is loaded. A good score in this category means having a good score even on speedtest, in fact the tests are almost the same

The foundamental issues to resolve to get a high score are:

Reduce render-blocking stylesheets
Enable text compression
Reduce render-blocking stylesheets
This is always a painful point. It depends a lot on the way you write your application styles but we can split all the possibilities in two macro blocks:

Who will use jsx style or similar and them inject styes with webpack inside the document
Who wants to use a preprocessor like sass / less or directly the css and inport the final css in the document
in both cases the problem is always the same, how can I decrease the render-blocking stylesheets?

There is no real solution but the roads are different:

Write my code in order to export two files, the essential ones to show my site and the remaining amount in the footer
Use jsx style for the essential style that will be imported directly in the head and all the external libraries (like bootstrap, materialize or foundation) the amount in the footer
Use the webpack plugin webpack-plugin-critical that puts the necessary CSS inline in the HTML documents and imports the other part in a css file automatically
Enabling text compression
NextJS does not minify your javascript but that¡¯s not a problem, just edit your next.config.js and use the webpack uglify plugin

const webpack = require(¡®webpack¡¯)
...#other your import
module.exports = {
   ...#the service worker plugins
   config.plugins = config.plugins.filter(
      (plugin) => (plugin.constructor.name !== ¡®UglifyJsPlugin¡¯)
   )
   config.plugins.push(
      new webpack.optimize.UglifyJsPlugin()
   )
   return config
}
This will force the uglify and minify of your javascript

Accessibility
Accessibility is the practice of making your websites usable by as many people as possible. This concept doesn¡¯t involve only people with disabilities, but it extends to everyone who is going to use site on bad conditions like low-end mobile devices or slow internet connection.

To get a high score, we need to fix this problems:

Page specifies valid language
Elements don¡¯t use Attributes correctly
Page specifies valid language
To fix this we need to rewrite the base _document page. The _document page is the base template that uses NextJS fills with the head and the body of our application. We usually do not have to rewrite it, but in this case it becomes necessary because we have to add an element to the html tag (and no, do not do it via javascript). Let¡¯s create the _document.js file inside the pages folder

import Document, { Head, Main, NextScript } from ¡®next/document¡¯
import flush from ¡®styled-jsx/server¡¯
export default class MyDocument extends Document {
  static getInitialProps({ renderPage }) {
   const { html, head, errorHtml, chunks } = renderPage()
   const styles = flush()
   return { html, head, errorHtml, chunks, styles }
  }
  render() {
    return (
      <html lang=¡±en¡±>
        <Head></Head>
        <body>
          {this.props.customValue}
          <Main />
          <NextScript />
        </body>
      </html>
    )
  }
}
The _document.js is a real React Component so we can use the props if our site needs to dynamically change the lang attribute content

Elements don¡¯t use Attributes correctly
This is a pure html issue. How many times do we forget to put the alttag to our images? The title on an iframe or just using a <div> inside the ul tag?

To eliminate the automatic <div>inserted by React (to avoid errors inside the ul <ul>) Nextjs integrates the React Fragments, this will also help us to decrease the size of our DOM.

If we want a good score we need to pay attention to these little things

Best practices
This is a collection of tips to modernize your web app and avoid the pitfalls of performance. Some are very obvious as the ¡°use of HTTPS¡± others are about javascript, such as ¡°Avoiding document.write()¡±

For the highest score, we must resolve the following:

Does not use HTTP/2 for all of its resources
Opens external anchors using rel=¡±noopener¡±
Does not use HTTP/2 for all of its resources
To fix it we just need to slightly edit the nginx virtualhost configuration

server {
  ...
  listen 443 ssl http2;

  ....
}
Some easy points here :)

Opens external anchors using rel=¡±noopener¡±
This is a very tiny tip. Add the attribute rel="noopener" in all your target="_blank" links. Why should we do this?

Imagine that a website you¡¯re linking to gets hacked. If you use just target="_blank" the malicious website has full control of your window through the window.opener API. It also tells the web browser to open the process in a separate thread which means your website won¡¯t get slower since the new window or tab won¡¯t be considered a child of your website.

No, it¡¯s not cool, add rel=¡±noopener¡± it¡¯s for your safety ;)


Our goal is to have a situation similar to the one above. Will it be simple? No, but we¡¯re on the right path, focusing a little more on the design of the website is very useful but not sufficient. We will clash with different issues such as the use of jquery, console errors, lighthouse may not like the contrast of your colors or the use of external libraries available only on http.

Is important having an excellent score? No, but it could help you have a good score on the Performance category because it would mean to have a good score on pagespeed and have more strength in terms of SEO.

But let¡¯s tell the truth, if you have arrived here, at the bottom of the article, is because you already know that all this just serves to feel more cool and to say ¡°I have 100% on lighthouse¡±, so, have good code night ;)

Thanks and stay tuned :)
```

barrage
Progressive
category
indicators
audit
traditional
attempts
combine
benefits
fundamental
Redirect
traffic
brand
via
recommend
virtualhost
resolve
critical
measure
compression
possibilities
preprocessor
decrease
essential
remain
amount
foundation
collection
modernize
avoid
pitfalls
obvious
external
slightly
stay tuned
correctly
eliminate
attention
Imagine
hacked
malicious
separate
slower
considered